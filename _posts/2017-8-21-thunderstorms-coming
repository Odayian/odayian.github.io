layout: post
title: Thunderstorms are coming

A few days ago, I came across a post on reddit that really piqued my interest. This post was pretty much what I wanted to accomplish as a side project but didn't have the proper knowlede to complete it. The concept overall is simple: parse a website for information, filter the content in to multiple objects,  post filtered informtion in to a chat program. For a better explanation of what I want to accomplish, you can view my post at: <link>.

This rabbithole of a project ended up taking me to [GitHub Link](https://github.com/bearlikelion/ao-killbot) where I found out this is almost exactly what I want. I wanted to get things up and running for myself. I cloned the repository to my Cloud9 account (web based IDE) and started to play around.  At the time, the readme didn't have the best instructions. I'm pretty sure I'm the second person to open this repository. Eventually, everything got set up in my configuration and I go to Cloud9's console and type 'node ao-killbot.js' excited to see it connect to my Discord server. Well...it didnt. After some research and no luck, I finally messaged the creator of the project for some help. I had to use a special link for Discord to invite this application as a bot to my server. ```https://discordapp.com/oauth2/authorize?&client_id=<CLIENT ID>&scope=bot&permissions=0``` It still didn't work. Found out that you need to add a scope and permissions level to the URL. I hit Enter again and it's now connected to the Discord server and the console logged "Ready and running". Minutes later, information was being sent to a specific channel that was set up for this bot.

One thing that doesn't last forever aparantly are Cloud9 workspaces. It looks like they shut down after a certain period of inactivity on their free accounts. Simple solution: Subscribe. I enter my credit card information, set everything up and not even 30 minutes later it does it again. Looks like I need to find a proper host instead of a web based IDE (which makes perfect sense, I was just hoping it would run longer). Research and many articles later I finally decided on using [Heroku](www.heroku.com). It looks like you get 550 hours/month for 2 dynos (instance of an application). If you register your credit card they'll add an extra 450 hours/month to your quota. 41 days of dyno time a month? Sign me up! There would only be one dyno running for the application since there isn't a front end application/dyno. If I were to run a front end dyno, it would take out of the same pool of time as the back end.

Setting up on Heroku was pretty easy. You select the type of environment and link it to a GitHub repository. There are options for auto deploy, auto update, working branch, etc. This is fantastic. Everything is up and running again....but it isnt. After more research I found out I needed to install a few more packages (which wasn't a problem). Click "Deploy" and I still get errors. More research. *Ding* I boot up cloud 9, add a "Procfile" with no extension with the following information inside: ```web: node ao-killbot.js```. This makes sense to me since it's what I normally run from the CLI where by default it was trying to run app.js. Once again the bot is up and running. Messages come in for about 20 minutes then the bot disconnects again. At this point I'm almost ready to throw in the towel for the evening but instead pulled a few more hairs out and came across a simple file change: ```worker: node ao-killbot.js``` Heroku won't suspend back-end services but will suspend a front-end service after 30 minutes of browswer activity.

I contact the developer and report all of my findings. He asks what I do for a living but explained that I'm taking an online bootcamp and my history of computers and coding. He liked what he heard and asked if I'd like to become a contributer to the repository and can add to it as I learn.

Overall, even though for most developers this would be a small task, I would consider it a great stride. Some people learn more by doing and figuring out then having it written out in a readme. If time allows, I prefer to work through issues and learn instead of following a readme and not knowing why something is done. 
